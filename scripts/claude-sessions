#!/bin/bash

# Claude Sessions Viewer
# Lists active Claude Code sessions with tracking information

# Source utils if available
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/claude-switcher-utils.sh" ]; then
    source "$SCRIPT_DIR/claude-switcher-utils.sh"
else
    BLUE='\033[0;34m'
    NC='\033[0m'
    print_status() { echo -e "${BLUE}[Claude Sessions]${NC} $1"; }
fi

# Clean up any stale session files first
cleanup_stale_sessions

echo ""
print_status "Active Claude Code Sessions:"
echo ""

# Check if sessions directory exists and has any files
if [ ! -d "$SESSIONS_DIR" ] || [ -z "$(ls -A "$SESSIONS_DIR" 2>/dev/null)" ]; then
    print_status "No active Claude sessions found"
    echo ""
    print_status "Sessions started with claude-pro, claude-aws, claude-vertex, claude-apikey, or claude-azure will appear here"
    echo ""
    print_status "Commands:"
    print_status "  claude-status   - Show current terminal's Claude configuration"
    print_status "  claude-sessions - Show all active Claude sessions (this command)"
    echo ""
    exit 0
fi

# Display header
printf "%-8s %-15s %-40s %-20s %-15s %s\n" "PID" "Provider" "Model" "Region/Project" "Session ID" "Uptime"
printf "%-8s %-15s %-40s %-20s %-15s %s\n" "----" "--------" "-----" "--------------" "----------" "------"

# Calculate uptime helper
calculate_uptime() {
    local start_time=$1
    local current_time=$(date +%s)
    local elapsed=$((current_time - start_time))
    
    local hours=$((elapsed / 3600))
    local minutes=$(((elapsed % 3600) / 60))
    local seconds=$((elapsed % 60))
    
    if [ $hours -gt 0 ]; then
        echo "${hours}h${minutes}m"
    elif [ $minutes -gt 0 ]; then
        echo "${minutes}m${seconds}s"
    else
        echo "${seconds}s"
    fi
}

# Iterate through session files and display info
found_sessions=false
for session_file in "$SESSIONS_DIR"/*; do
    if [ ! -f "$session_file" ]; then
        continue
    fi
    
    # Source the session file to get variables
    source "$session_file"
    
    # Verify the PID is still running (double-check)
    if ! ps -p "$CLAUDE_SESSION_PID" > /dev/null 2>&1; then
        continue
    fi
    
    found_sessions=true
    
    # Determine what to show in Region/Project column
    region_or_project=""
    if [ -n "$CLAUDE_SESSION_REGION" ]; then
        region_or_project="$CLAUDE_SESSION_REGION"
    elif [ -n "$CLAUDE_SESSION_PROJECT" ]; then
        # Truncate project ID if too long
        if [ ${#CLAUDE_SESSION_PROJECT} -gt 20 ]; then
            region_or_project="${CLAUDE_SESSION_PROJECT:0:17}..."
        else
            region_or_project="$CLAUDE_SESSION_PROJECT"
        fi
    else
        region_or_project="N/A"
    fi
    
    # Calculate uptime
    uptime=$(calculate_uptime "$CLAUDE_SESSION_START_TIME")
    
    # Truncate model name if too long
    model_display="$CLAUDE_SESSION_MODEL"
    if [ ${#model_display} -gt 40 ]; then
        model_display="${model_display:0:37}..."
    fi
    
    # Extract short session ID (last part after last hyphen)
    session_id_short=$(echo "$CLAUDE_SESSION_ID" | rev | cut -d'-' -f1 | rev)
    
    printf "%-8s %-15s %-40s %-20s %-15s %s\n" \
        "$CLAUDE_SESSION_PID" \
        "$CLAUDE_SESSION_PROVIDER" \
        "$model_display" \
        "$region_or_project" \
        "$session_id_short" \
        "$uptime"
done

# Also check for native `claude` processes (not launched via our wrapper scripts)
# These won't have session tracking files, but we can still show them
for pid in $(pgrep -x "claude" 2>/dev/null); do
    # Skip if we already showed this PID (has a tracking file)
    if [ -f "$SESSIONS_DIR/$pid" ]; then
        continue
    fi
    
    # Verify it's actually a claude process
    if ! ps -p "$pid" -o command= 2>/dev/null | grep -q "claude"; then
        continue
    fi
    
    # Check if this process is a child of any tracked session
    # Walk up the process tree to see if we find a tracked session
    is_child_of_tracked=false
    current_ppid=$(ps -p "$pid" -o ppid= 2>/dev/null | tr -d ' ')
    while [ -n "$current_ppid" ] && [ "$current_ppid" != "1" ]; do
        if [ -f "$SESSIONS_DIR/$current_ppid" ]; then
            is_child_of_tracked=true
            break
        fi
        current_ppid=$(ps -p "$current_ppid" -o ppid= 2>/dev/null | tr -d ' ')
    done
    
    # Skip if this is a child of a tracked session
    if [ "$is_child_of_tracked" = true ]; then
        continue
    fi
    
    found_sessions=true
    
    # Calculate uptime from process start time
    if command -v ps >/dev/null 2>&1; then
        # Get process start time (seconds since epoch on macOS requires different approach)
        # Use lstart which gives us the start time, then calculate elapsed
        start_time_str=$(ps -p "$pid" -o lstart= 2>/dev/null)
        if [ -n "$start_time_str" ]; then
            # Convert to epoch (this is macOS-compatible)
            start_epoch=$(date -j -f "%a %b %d %T %Y" "$start_time_str" "+%s" 2>/dev/null || echo "0")
            if [ "$start_epoch" != "0" ]; then
                uptime=$(calculate_uptime "$start_epoch")
            else
                uptime="Unknown"
            fi
        else
            uptime="Unknown"
        fi
    else
        uptime="Unknown"
    fi
    
    # Display native session with limited info
    printf "%-8s %-15s %-40s %-20s %-15s %s\n" \
        "$pid" \
        "Native Claude" \
        "(no tracking)" \
        "N/A" \
        "N/A" \
        "$uptime"
done

if [ "$found_sessions" = false ]; then
    echo ""
    print_status "No active Claude sessions found"
    print_status "Sessions started with claude-pro, claude-aws, claude-vertex, claude-apikey, or claude-azure will appear here"
fi

echo ""
print_status "Commands:"
print_status "  claude-status   - Show current terminal's Claude configuration"
print_status "  claude-sessions - Show all active Claude sessions (this command)"
echo ""
